

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>web.proxy &mdash; PyZMQ 2.2dev documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/zeromq.ico"/>
    <link rel="top" title="PyZMQ 2.2dev documentation" href="../../index.html" />
    <link rel="up" title="The PyZMQ API" href="../index.html" />
    <link rel="next" title="web.zmqweb" href="zmq.web.zmqweb.html" />
    <link rel="prev" title="utils.rebuffer" href="zmq.utils.rebuffer.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../index.html"><img src="../../_static/logo.png" border="0" alt="PyZMQ Documentation"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="zmq.web.zmqweb.html" title="web.zmqweb"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="zmq.utils.rebuffer.html" title="utils.rebuffer"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>
       <li><a href="../index.html">API</a> &raquo;</li>

          <li><a href="../index.html" accesskey="U">The PyZMQ API</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">web.proxy</a><ul>
<li><a class="reference internal" href="#module-zmq.web.proxy">Module: <tt class="docutils literal"><span class="pre">web.proxy</span></tt></a></li>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#zmqapplicationproxy"><tt class="docutils literal"><span class="pre">ZMQApplicationProxy</span></tt></a></li>
<li><a class="reference internal" href="#zmqrequesthandlerproxy"><tt class="docutils literal"><span class="pre">ZMQRequestHandlerProxy</span></tt></a></li>
<li><a class="reference internal" href="#zmqstreamingapplicationproxy"><tt class="docutils literal"><span class="pre">ZMQStreamingApplicationProxy</span></tt></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="zmq.utils.rebuffer.html"
                        title="previous chapter">utils.rebuffer</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="zmq.web.zmqweb.html"
                        title="next chapter">web.zmqweb</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/api/generated/zmq.web.proxy.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="web-proxy">
<h1>web.proxy<a class="headerlink" href="#web-proxy" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-zmq.web.proxy">
<span id="module-web-proxy"></span><h2>Module: <tt class="xref py py-mod docutils literal"><span class="pre">web.proxy</span></tt><a class="headerlink" href="#module-zmq.web.proxy" title="Permalink to this headline">¶</a></h2>
<p>Proxy classes for forwarding tornado handlers to be run in separate processes.</p>
<p>This module uses ZeroMQ/PyZMQ sockets (DEALER/ROUTER) to enable individual
Tornado handlers to be run in a separate backend process. Through the
usage of DEALER/ROUTER sockets, multiple backend processes for a given
handler can be started and requests will be load balanced among the backend
processes.</p>
<p>Authors:</p>
<ul class="simple">
<li>Brian Granger</li>
</ul>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="zmqapplicationproxy">
<h3><a class="reference internal" href="#zmq.web.proxy.ZMQApplicationProxy" title="zmq.web.proxy.ZMQApplicationProxy"><tt class="xref py py-class docutils literal"><span class="pre">ZMQApplicationProxy</span></tt></a><a class="headerlink" href="#zmqapplicationproxy" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="zmq.web.proxy.ZMQApplicationProxy">
<em class="property">class </em><tt class="descclassname">zmq.web.proxy.</tt><tt class="descname">ZMQApplicationProxy</tt><big>(</big><em>loop=None</em>, <em>context=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQApplicationProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>A proxy for a ZeroMQ based ZMQApplication that is using ZMQHTTPRequest.</p>
<p>This class is a proxy for a backend that is running a
ZMQApplication and MUST be used with the ZMQHTTPRequest class. This
version sends the reply parts (each generated by RequestHandler.flush) as
a single multipart message for low latency replies. See
ZMQStreamingApplicationProxy, for a version that has higher latency, but
which sends each reply part as a separate zmq message.</p>
<dl class="method">
<dt id="zmq.web.proxy.ZMQApplicationProxy.bind">
<tt class="descname">bind</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQApplicationProxy.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the service client to the proto://ip:port given in the url.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQApplicationProxy.connect">
<tt class="descname">connect</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQApplicationProxy.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the service client to the proto://ip:port given in the url.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQApplicationProxy.send_request">
<tt class="descname">send_request</tt><big>(</big><em>request</em>, <em>args</em>, <em>kwargs</em>, <em>handler</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQApplicationProxy.send_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request to the service.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="zmqrequesthandlerproxy">
<h3><a class="reference internal" href="#zmq.web.proxy.ZMQRequestHandlerProxy" title="zmq.web.proxy.ZMQRequestHandlerProxy"><tt class="xref py py-class docutils literal"><span class="pre">ZMQRequestHandlerProxy</span></tt></a><a class="headerlink" href="#zmqrequesthandlerproxy" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy">
<em class="property">class </em><tt class="descclassname">zmq.web.proxy.</tt><tt class="descname">ZMQRequestHandlerProxy</tt><big>(</big><em>application</em>, <em>request</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>A handler for use with a ZeroMQ backend service client.</p>
<dl class="attribute">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.SUPPORTED_METHODS">
<tt class="descname">SUPPORTED_METHODS</tt><em class="property"> = ('GET', 'HEAD', 'POST', 'DELETE', 'PUT', 'OPTIONS')</em><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.SUPPORTED_METHODS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.add_header">
<tt class="descname">add_header</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.add_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the given response header and value.</p>
<p>Unlike <cite>set_header</cite>, <cite>add_header</cite> may be called multiple times
to return multiple values for the same header.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.async_callback">
<tt class="descname">async_callback</tt><big>(</big><em>callback</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.async_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Obsolete - catches exceptions from the wrapped function.</p>
<p>This function is unnecessary since Tornado 1.1.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.check_xsrf_cookie">
<tt class="descname">check_xsrf_cookie</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.check_xsrf_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies that the &#8216;_xsrf&#8217; cookie matches the &#8216;_xsrf&#8217; argument.</p>
<p>To prevent cross-site request forgery, we set an &#8216;_xsrf&#8217;
cookie and include the same value as a non-cookie
field with all POST requests. If the two do not match, we
reject the form submission as a potential forgery.</p>
<p>The _xsrf value may be set as either a form field named _xsrf
or in a custom HTTP header named X-XSRFToken or X-CSRFToken
(the latter is accepted for compatibility with Django).</p>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a></p>
<p>Prior to release 1.1.1, this check was ignored if the HTTP header
&#8220;X-Requested-With: XMLHTTPRequest&#8221; was present.  This exception
has been shown to be insecure and has been removed.  For more
information please see
<a class="reference external" href="http://www.djangoproject.com/weblog/2011/feb/08/security/">http://www.djangoproject.com/weblog/2011/feb/08/security/</a>
<a class="reference external" href="http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails">http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails</a></p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all headers and content for this response.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.clear_all_cookies">
<tt class="descname">clear_all_cookies</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.clear_all_cookies" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes all the cookies the user sent with this request.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.clear_cookie">
<tt class="descname">clear_cookie</tt><big>(</big><em>name</em>, <em>path='/'</em>, <em>domain=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.clear_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes the cookie with the given name.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.compute_etag">
<tt class="descname">compute_etag</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.compute_etag" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the etag header to be used for this request.</p>
<p>May be overridden to provide custom etag implementations,
or may return None to disable tornado&#8217;s default etag support.</p>
</dd></dl>

<dl class="attribute">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.cookies">
<tt class="descname">cookies</tt><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.cookies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.create_signed_value">
<tt class="descname">create_signed_value</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.create_signed_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Signs and timestamps a string so it cannot be forged.</p>
<p>Normally used via set_secure_cookie, but provided as a separate
method for non-cookie uses.  To decode a value not stored
as a cookie use the optional value argument to get_secure_cookie.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.create_template_loader">
<tt class="descname">create_template_loader</tt><big>(</big><em>template_path</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.create_template_loader" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.current_user">
<tt class="descname">current_user</tt><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.current_user" title="Permalink to this definition">¶</a></dt>
<dd><p>The authenticated user for this request.</p>
<p>Determined by either get_current_user, which you can override to
set the user based on, e.g., a cookie. If that method is not
overridden, this method always returns None.</p>
<p>We lazy-load the current user the first time this method is called
and cache the result after that.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.decode_argument">
<tt class="descname">decode_argument</tt><big>(</big><em>value</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.decode_argument" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes an argument from the request.</p>
<p>The argument has been percent-decoded and is now a byte string.
By default, this method decodes the argument as utf-8 and returns
a unicode string, but this may be overridden in subclasses.</p>
<p>This method is used as a filter for both get_argument() and for
values extracted from the url and passed to get()/post()/etc.</p>
<p>The name of the argument is provided if known, but may be None
(e.g. for unnamed groups in the url regex).</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.delete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.finish">
<tt class="descname">finish</tt><big>(</big><em>chunk=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Finishes this response, ending the HTTP request.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.flush">
<tt class="descname">flush</tt><big>(</big><em>include_footers=False</em>, <em>callback=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flushes the current output buffer to the network.</p>
<p>The <tt class="docutils literal"><span class="pre">callback</span></tt> argument, if given, can be used for flow control:
it will be run when all flushed data has been written to the socket.
Note that only one flush callback can be outstanding at a time;
if another flush occurs before the previous flush&#8217;s callback
has been run, the previous callback will be discarded.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get">
<tt class="descname">get</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_argument">
<tt class="descname">get_argument</tt><big>(</big><em>name</em>, <em>default=</em><span class="optional">[</span><span class="optional">]</span>, <em>strip=True</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_argument" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the argument with the given name.</p>
<p>If default is not provided, the argument is considered to be
required, and we throw an HTTP 400 exception if it is missing.</p>
<p>If the argument appears in the url more than once, we return the
last value.</p>
<p>The returned value is always unicode.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_arguments">
<tt class="descname">get_arguments</tt><big>(</big><em>name</em>, <em>strip=True</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the arguments with the given name.</p>
<p>If the argument is not present, returns an empty list.</p>
<p>The returned values are always unicode.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_browser_locale">
<tt class="descname">get_browser_locale</tt><big>(</big><em>default='en_US'</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_browser_locale" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the user&#8217;s locale from Accept-Language header.</p>
<p>See <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4</a></p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_cookie">
<tt class="descname">get_cookie</tt><big>(</big><em>name</em>, <em>default=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the value of the cookie with the given name, else default.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_current_user">
<tt class="descname">get_current_user</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_current_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to determine the current user from, e.g., a cookie.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_login_url">
<tt class="descname">get_login_url</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_login_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to customize the login URL based on the request.</p>
<p>By default, we use the &#8216;login_url&#8217; application setting.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_secure_cookie">
<tt class="descname">get_secure_cookie</tt><big>(</big><em>name</em>, <em>value=None</em>, <em>max_age_days=31</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_secure_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the given signed cookie if it validates, or None.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_status">
<tt class="descname">get_status</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the status code for our response.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_template_path">
<tt class="descname">get_template_path</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_template_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to customize template path for each handler.</p>
<p>By default, we use the &#8216;template_path&#8217; application setting.
Return None to load templates relative to the calling file.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.get_user_locale">
<tt class="descname">get_user_locale</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.get_user_locale" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to determine the locale from the authenticated user.</p>
<p>If None is returned, we fall back to get_browser_locale().</p>
<p>This method should return a tornado.locale.Locale object,
most likely obtained via a call like tornado.locale.get(&#8220;en&#8221;)</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.head">
<tt class="descname">head</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.head" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.initialize">
<tt class="descname">initialize</tt><big>(</big><em>proxy</em>, <em>timeout=0</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize with a proxy and timeout.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>proxy</strong> : ZMQApplicationProxy. ZMQStreamingApplicationProxy</p>
<blockquote>
<div><p>A proxy instance that will be used to send requests to a backend
process.</p>
</div></blockquote>
<p><strong>timeout</strong> : int</p>
<blockquote class="last">
<div><p>The timeout, in milliseconds. If this timeout is reached
before the backend&#8217;s first reply, then the server is sent a
status code of 504 to the browser to indicate a gateway/proxy
timeout. Set to 0 or a negative number to disable (infinite 
timeout).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.locale">
<tt class="descname">locale</tt><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.locale" title="Permalink to this definition">¶</a></dt>
<dd><p>The local for the current session.</p>
<p>Determined by either get_user_locale, which you can override to
set the locale based on, e.g., a user preference stored in a
database, or get_browser_locale, which uses the Accept-Language
header.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.on_connection_close">
<tt class="descname">on_connection_close</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.on_connection_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Called in async handlers if the client closed the connection.</p>
<p>Override this to clean up resources associated with
long-lived connections.  Note that this method is called only if
the connection was closed during asynchronous processing; if you
need to do cleanup after every request override <cite>on_finish</cite>
instead.</p>
<p>Proxies may keep a connection open for a time (perhaps
indefinitely) after the client has gone away, so this method
may not be called promptly after the end user closes their
connection.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.on_finish">
<tt class="descname">on_finish</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.on_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after the end of a request.</p>
<p>Override this method to perform cleanup, logging, etc.
This method is a counterpart to <cite>prepare</cite>.  <tt class="docutils literal"><span class="pre">on_finish</span></tt> may
not produce any output, as it is called after the response
has been sent to the client.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.options">
<tt class="descname">options</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.post">
<tt class="descname">post</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.post" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.prepare">
<tt class="descname">prepare</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called at the beginning of a request before <cite>get</cite>/<cite>post</cite>/etc.</p>
<p>Override this method to perform common initialization regardless
of the request method.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.put">
<tt class="descname">put</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.put" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.redirect">
<tt class="descname">redirect</tt><big>(</big><em>url</em>, <em>permanent=False</em>, <em>status=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.redirect" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends a redirect to the given (optionally relative) URL.</p>
<p>If the <tt class="docutils literal"><span class="pre">status</span></tt> argument is specified, that value is used as the
HTTP status code; otherwise either 301 (permanent) or 302
(temporary) is chosen based on the <tt class="docutils literal"><span class="pre">permanent</span></tt> argument.
The default is 302 (temporary).</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.render">
<tt class="descname">render</tt><big>(</big><em>template_name</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders the template with the given arguments as the response.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.render_string">
<tt class="descname">render_string</tt><big>(</big><em>template_name</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.render_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the given template with the given arguments.</p>
<p>We return the generated string. To generate and write a template
as a response, use render() above.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.require_setting">
<tt class="descname">require_setting</tt><big>(</big><em>name</em>, <em>feature='this feature'</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.require_setting" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an exception if the given app setting is not defined.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.reverse_url">
<tt class="descname">reverse_url</tt><big>(</big><em>name</em>, <em>*args</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.reverse_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <cite>Application.reverse_url</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.send_error">
<tt class="descname">send_error</tt><big>(</big><em>status_code=500</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.send_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends the given HTTP error code to the browser.</p>
<p>If <cite>flush()</cite> has already been called, it is not possible to send
an error, so this method will simply terminate the response.
If output has been written but not yet flushed, it will be discarded
and replaced with the error page.</p>
<p>Override <cite>write_error()</cite> to customize the error page that is returned.
Additional keyword arguments are passed through to <cite>write_error</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.set_cookie">
<tt class="descname">set_cookie</tt><big>(</big><em>name</em>, <em>value</em>, <em>domain=None</em>, <em>expires=None</em>, <em>path='/'</em>, <em>expires_days=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.set_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the given cookie name/value with the given options.</p>
<p>Additional keyword arguments are set on the Cookie.Morsel
directly.
See <a class="reference external" href="http://docs.python.org/library/cookie.html#morsel-objects">http://docs.python.org/library/cookie.html#morsel-objects</a>
for available attributes.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.set_default_headers">
<tt class="descname">set_default_headers</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.set_default_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this to set HTTP headers at the beginning of the request.</p>
<p>For example, this is the place to set a custom <tt class="docutils literal"><span class="pre">Server</span></tt> header.
Note that setting such headers in the normal flow of request
processing may not do what you want, since headers may be reset
during error handling.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.set_header">
<tt class="descname">set_header</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.set_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the given response header name and value.</p>
<p>If a datetime is given, we automatically format it according to the
HTTP specification. If the value is not a string, we convert it to
a string. All header values are then encoded as UTF-8.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.set_secure_cookie">
<tt class="descname">set_secure_cookie</tt><big>(</big><em>name</em>, <em>value</em>, <em>expires_days=30</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.set_secure_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Signs and timestamps a cookie so it cannot be forged.</p>
<p>You must specify the <tt class="docutils literal"><span class="pre">cookie_secret</span></tt> setting in your Application
to use this method. It should be a long, random sequence of bytes
to be used as the HMAC secret for the signature.</p>
<p>To read a cookie set with this method, use <cite>get_secure_cookie()</cite>.</p>
<p>Note that the <tt class="docutils literal"><span class="pre">expires_days</span></tt> parameter sets the lifetime of the
cookie in the browser, but is independent of the <tt class="docutils literal"><span class="pre">max_age_days</span></tt>
parameter to <cite>get_secure_cookie</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.set_status">
<tt class="descname">set_status</tt><big>(</big><em>status_code</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.set_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the status code for our response.</p>
</dd></dl>

<dl class="attribute">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.settings">
<tt class="descname">settings</tt><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>An alias for <cite>self.application.settings</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.static_url">
<tt class="descname">static_url</tt><big>(</big><em>path</em>, <em>include_host=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.static_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a static URL for the given relative static file path.</p>
<p>This method requires you set the &#8216;static_path&#8217; setting in your
application (which specifies the root directory of your static
files).</p>
<p>We append ?v=&lt;signature&gt; to the returned URL, which makes our
static file handler set an infinite expiration header on the
returned content. The signature is based on the content of the
file.</p>
<p>By default this method returns URLs relative to the current
host, but if <tt class="docutils literal"><span class="pre">include_host</span></tt> is true the URL returned will be
absolute.  If this handler has an <tt class="docutils literal"><span class="pre">include_host</span></tt> attribute,
that value will be used as the default for all <cite>static_url</cite>
calls that do not pass <tt class="docutils literal"><span class="pre">include_host</span></tt> as a keyword argument.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.write">
<tt class="descname">write</tt><big>(</big><em>chunk</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the given chunk to the output buffer.</p>
<p>To write the output to the network, use the flush() method below.</p>
<p>If the given chunk is a dictionary, we write it as JSON and set
the Content-Type of the response to be application/json.
(if you want to send JSON as a different Content-Type, call
set_header <em>after</em> calling write()).</p>
<p>Note that lists are not converted to JSON because of a potential
cross-site security vulnerability.  All JSON output should be
wrapped in a dictionary.  More details at
<a class="reference external" href="http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx">http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx</a></p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.write_error">
<tt class="descname">write_error</tt><big>(</big><em>status_code</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.write_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to implement custom error pages.</p>
<p><tt class="docutils literal"><span class="pre">write_error</span></tt> may call <cite>write</cite>, <cite>render</cite>, <cite>set_header</cite>, etc
to produce output as usual.</p>
<p>If this error was caused by an uncaught exception, an <tt class="docutils literal"><span class="pre">exc_info</span></tt>
triple will be available as <tt class="docutils literal"><span class="pre">kwargs[&quot;exc_info&quot;]</span></tt>.  Note that this
exception may not be the &#8220;current&#8221; exception for purposes of
methods like <tt class="docutils literal"><span class="pre">sys.exc_info()</span></tt> or <tt class="docutils literal"><span class="pre">traceback.format_exc</span></tt>.</p>
<p>For historical reasons, if a method <tt class="docutils literal"><span class="pre">get_error_html</span></tt> exists,
it will be used instead of the default <tt class="docutils literal"><span class="pre">write_error</span></tt> implementation.
<tt class="docutils literal"><span class="pre">get_error_html</span></tt> returned a string instead of producing output
normally, and had different semantics for exception handling.
Users of <tt class="docutils literal"><span class="pre">get_error_html</span></tt> are encouraged to convert their code
to override <tt class="docutils literal"><span class="pre">write_error</span></tt> instead.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.xsrf_form_html">
<tt class="descname">xsrf_form_html</tt><big>(</big><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.xsrf_form_html" title="Permalink to this definition">¶</a></dt>
<dd><p>An HTML &lt;input/&gt; element to be included with all POST forms.</p>
<p>It defines the _xsrf input value, which we check on all POST
requests to prevent cross-site request forgery. If you have set
the &#8216;xsrf_cookies&#8217; application setting, you must include this
HTML within all of your HTML forms.</p>
<p>See check_xsrf_cookie() above for more information.</p>
</dd></dl>

<dl class="attribute">
<dt id="zmq.web.proxy.ZMQRequestHandlerProxy.xsrf_token">
<tt class="descname">xsrf_token</tt><a class="headerlink" href="#zmq.web.proxy.ZMQRequestHandlerProxy.xsrf_token" title="Permalink to this definition">¶</a></dt>
<dd><p>The XSRF-prevention token for the current user/session.</p>
<p>To prevent cross-site request forgery, we set an &#8216;_xsrf&#8217; cookie
and include the same &#8216;_xsrf&#8217; value as an argument with all POST
requests. If the two do not match, we reject the form submission
as a potential forgery.</p>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a></p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="zmqstreamingapplicationproxy">
<h3><a class="reference internal" href="#zmq.web.proxy.ZMQStreamingApplicationProxy" title="zmq.web.proxy.ZMQStreamingApplicationProxy"><tt class="xref py py-class docutils literal"><span class="pre">ZMQStreamingApplicationProxy</span></tt></a><a class="headerlink" href="#zmqstreamingapplicationproxy" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="zmq.web.proxy.ZMQStreamingApplicationProxy">
<em class="property">class </em><tt class="descclassname">zmq.web.proxy.</tt><tt class="descname">ZMQStreamingApplicationProxy</tt><big>(</big><em>loop=None</em>, <em>context=None</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQStreamingApplicationProxy" title="Permalink to this definition">¶</a></dt>
<dd><p>A proxy for a ZeroMQ based ZMQApplication that is using ZMQStreamingHTTPRequest.</p>
<p>This class is a proxy for a backend that is running a
ZMQApplication and MUST be used with the ZMQStreamingHTTPRequest class.
This version sends the reply parts (each generated by RequestHandler.flush)
as separate zmq messages to enable streaming replies. See
ZMQApplicationProxy, for a version that has lower latency, but which sends
all reply parts as a single zmq message.</p>
<dl class="method">
<dt id="zmq.web.proxy.ZMQStreamingApplicationProxy.bind">
<tt class="descname">bind</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQStreamingApplicationProxy.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the service client to the proto://ip:port given in the url.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQStreamingApplicationProxy.connect">
<tt class="descname">connect</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQStreamingApplicationProxy.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the service client to the proto://ip:port given in the url.</p>
</dd></dl>

<dl class="method">
<dt id="zmq.web.proxy.ZMQStreamingApplicationProxy.send_request">
<tt class="descname">send_request</tt><big>(</big><em>request</em>, <em>args</em>, <em>kwargs</em>, <em>handler</em>, <em>timeout</em><big>)</big><a class="headerlink" href="#zmq.web.proxy.ZMQStreamingApplicationProxy.send_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request to the service.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="zmq.web.zmqweb.html" title="web.zmqweb"
             >next</a> |</li>
        <li class="right" >
          <a href="zmq.utils.rebuffer.html" title="utils.rebuffer"
             >previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../search.html">search</a>|&nbsp;</li>
       <li><a href="../index.html">API</a> &raquo;</li>

          <li><a href="../index.html" >The PyZMQ API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2011, Brian E. Granger &amp; Min Ragan-Kelley.  
ØMQ logo © iMatix Corportation, used under the Creative Commons Attribution-Share Alike 3.0 License.  
Python logo ™ of the Python Software Foundation, used by Min RK with permission from the Foundation.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>