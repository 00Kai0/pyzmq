

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tornado Eventloop with PyZMQ &mdash; PyZMQ 2.1.11 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.1.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/zeromq.ico"/>
    <link rel="top" title="PyZMQ 2.1.11 documentation" href="index.html" />
    <link rel="next" title="Asynchronous Logging via PyZMQ" href="logging.html" />
    <link rel="prev" title="Devices in PyZMQ" href="devices.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/logo.png" border="0" alt="PyZMQ Documentation"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="logging.html" title="Asynchronous Logging via PyZMQ"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="devices.html" title="Devices in PyZMQ"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
       <li><a href="api/index.html">API</a> &raquo;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tornado Eventloop with PyZMQ</a><ul>
<li><a class="reference internal" href="#install"><tt class="docutils literal"><span class="pre">install()</span></tt></a></li>
<li><a class="reference internal" href="#send"><tt class="docutils literal"><span class="pre">send()</span></tt></a></li>
<li><a class="reference internal" href="#on-recv"><tt class="docutils literal"><span class="pre">on_recv()</span></tt></a></li>
<li><a class="reference internal" href="#flush"><tt class="docutils literal"><span class="pre">flush()</span></tt></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="devices.html"
                        title="previous chapter">Devices in PyZMQ</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="logging.html"
                        title="next chapter">Asynchronous Logging via PyZMQ</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/eventloop.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tornado-eventloop-with-pyzmq">
<span id="eventloop"></span><h1>Tornado Eventloop with PyZMQ<a class="headerlink" href="#tornado-eventloop-with-pyzmq" title="Permalink to this headline">¶</a></h1>
<p>Facebook&#8217;s <a class="reference external" href="https://github.com/facebook/tornado">Tornado</a> includes an eventloop for handing poll events on filedescriptors and
native sockets. We have included a small part of Tornado (specifically its
<a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#module-zmq.eventloop.ioloop" title="zmq.eventloop.ioloop"><tt class="xref py py-mod docutils literal"><span class="pre">ioloop</span></tt></a>), and adapted its <tt class="xref py py-class docutils literal"><span class="pre">IOStream</span></tt> class into <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream" title="zmq.eventloop.zmqstream.ZMQStream"><tt class="xref py py-class docutils literal"><span class="pre">ZMQStream</span></tt></a> for
handling poll events on ØMQ sockets. A ZMQStream object works much like a Socket object,
but instead of calling <a class="reference internal" href="api/generated/zmq.core.socket.html#zmq.core.socket.Socket.recv" title="zmq.core.socket.Socket.recv"><tt class="xref py py-meth docutils literal"><span class="pre">recv()</span></tt></a> directly, you register a callback with
<a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.on_recv" title="zmq.eventloop.zmqstream.ZMQStream.on_recv"><tt class="xref py py-meth docutils literal"><span class="pre">on_recv()</span></tt></a>. callbacks can also be registered for send and error events
with <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.on_send" title="zmq.eventloop.zmqstream.ZMQStream.on_send"><tt class="xref py py-meth docutils literal"><span class="pre">on_send()</span></tt></a> and <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.on_err" title="zmq.eventloop.zmqstream.ZMQStream.on_err"><tt class="xref py py-meth docutils literal"><span class="pre">on_err()</span></tt></a> respectively.</p>
<div class="section" id="install">
<h2><tt class="xref py py-func docutils literal"><span class="pre">install()</span></tt><a class="headerlink" href="#install" title="Permalink to this headline">¶</a></h2>
<p>With PyZMQ&#8217;s ioloop, you can use zmq sockets in any tornado application.  You must first
install PyZMQ&#8217;s <a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.IOLoop" title="zmq.eventloop.ioloop.IOLoop"><tt class="xref py py-class docutils literal"><span class="pre">IOLoop</span></tt></a>, with the <a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.install" title="zmq.eventloop.ioloop.install"><tt class="xref py py-func docutils literal"><span class="pre">ioloop.install()</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">zmq.eventloop</span> <span class="kn">import</span> <span class="n">ioloop</span>
<span class="n">ioloop</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>
</pre></div>
</div>
<p>This sets the global instance of <tt class="xref py py-class docutils literal"><span class="pre">tornado.ioloop.IOLoop</span></tt> with the global instance of
our IOLoop class. The reason this must happen is that tornado objects avoid having to pass
the active IOLoop instance around by having a staticmethod <a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.IOLoop.instance" title="zmq.eventloop.ioloop.IOLoop.instance"><tt class="xref py py-meth docutils literal"><span class="pre">IOLoop.instance()</span></tt></a>, which
always returns the active instance. If PyZMQ&#8217;s IOLoop is installed after the first call to
<a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.IOLoop.instance" title="zmq.eventloop.ioloop.IOLoop.instance"><tt class="xref py py-meth docutils literal"><span class="pre">IOLoop.instance()</span></tt></a> (called in almost every tornado object constructor), then it will
raise an <tt class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></tt>, because the global IOLoop instance has already been
created, and proceeding would result in not all objects being associated with the right
IOLoop.</p>
<p>It is possible to use PyZMQ sockets with tornado <em>without</em> calling <a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.install" title="zmq.eventloop.ioloop.install"><tt class="xref py py-func docutils literal"><span class="pre">ioloop.install()</span></tt></a>,
but it is less convenient. First, you must instruct the tornado IOLoop to use the zmq poller:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">tornado.ioloop</span> <span class="kn">import</span> <span class="n">IOLoop</span>
<span class="kn">from</span> <span class="nn">zmq.eventloop.ioloop</span> <span class="kn">import</span> <span class="n">ZMQPoller</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="p">(</span><span class="n">ZMQPoller</span><span class="p">())</span>
</pre></div>
</div>
<p>Then, when you instantiate tornado and ZMQStream objects, you must pass the <cite>io_loop</cite>
argument to ensure that they use this loop, instead of the global instance.  You can
install this IOLoop as the global tornado instance, with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">loop</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>
</pre></div>
</div>
<p>but it will <strong>NOT</strong> be the global <em>pyzmq</em> IOLoop instance, so it must still be passed to
your ZMQStream constructors.</p>
</div>
<div class="section" id="send">
<h2><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt><a class="headerlink" href="#send" title="Permalink to this headline">¶</a></h2>
<p>ZMQStream objects do have <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.send" title="zmq.eventloop.zmqstream.ZMQStream.send"><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt></a> and <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.send_multipart" title="zmq.eventloop.zmqstream.ZMQStream.send_multipart"><tt class="xref py py-meth docutils literal"><span class="pre">send_multipart()</span></tt></a>
methods, which behaves the same way as <a class="reference internal" href="api/generated/zmq.core.socket.html#zmq.core.socket.Socket.send" title="zmq.core.socket.Socket.send"><tt class="xref py py-meth docutils literal"><span class="pre">Socket.send()</span></tt></a>, but instead of sending right
away, the <a class="reference internal" href="api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.IOLoop" title="zmq.eventloop.ioloop.IOLoop"><tt class="xref py py-class docutils literal"><span class="pre">IOLoop</span></tt></a> will wait until socket is able to send (for instance if <tt class="docutils literal"><span class="pre">HWM</span></tt>
is met, or a <tt class="docutils literal"><span class="pre">REQ/REP</span></tt> pattern prohibits sending at a certain point). Messages sent via
send will also be passed to the callback registered with <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.on_send" title="zmq.eventloop.zmqstream.ZMQStream.on_send"><tt class="xref py py-meth docutils literal"><span class="pre">on_send()</span></tt></a> after
sending.</p>
</div>
<div class="section" id="on-recv">
<h2><tt class="xref py py-meth docutils literal"><span class="pre">on_recv()</span></tt><a class="headerlink" href="#on-recv" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.on_recv" title="zmq.eventloop.zmqstream.ZMQStream.on_recv"><tt class="xref py py-meth docutils literal"><span class="pre">ZMQStream.on_recv()</span></tt></a> is the primary method for using a ZMQStream. It registers a
callback to fire with messages as they are received, which will <em>always</em> be multipart,
even if its length is 1. You can easily use this to build things like an echo socket:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">zmq</span><span class="o">.</span><span class="n">REP</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s">&#39;tcp://localhost:12345&#39;</span><span class="p">)</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>
<span class="n">stream</span> <span class="o">=</span> <span class="n">ZMQStream</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">stream</span><span class="o">.</span><span class="n">send_multipart</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">stream</span><span class="o">.</span><span class="n">on_recv</span><span class="p">(</span><span class="n">echo</span><span class="p">)</span>
<span class="n">loop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>on_recv can also take a <cite>copy</cite> flag, just like <a class="reference internal" href="api/generated/zmq.core.socket.html#zmq.core.socket.Socket.recv" title="zmq.core.socket.Socket.recv"><tt class="xref py py-meth docutils literal"><span class="pre">Socket.recv()</span></tt></a>. If <cite>copy=False</cite>, then
callbacks registered with on_recv will receive tracked <a class="reference internal" href="api/generated/zmq.core.message.html#zmq.core.message.Message" title="zmq.core.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> objects instead of
bytes.</p>
</div>
<div class="section" id="flush">
<h2><tt class="xref py py-meth docutils literal"><span class="pre">flush()</span></tt><a class="headerlink" href="#flush" title="Permalink to this headline">¶</a></h2>
<p>Sometimes with an eventloop, there can be multiple events ready on a single iteration of
the loop. The <a class="reference internal" href="api/generated/zmq.eventloop.zmqstream.html#zmq.eventloop.zmqstream.ZMQStream.flush" title="zmq.eventloop.zmqstream.ZMQStream.flush"><tt class="xref py py-meth docutils literal"><span class="pre">flush()</span></tt></a> method allows developers to pull messages off of
the queue to enforce some priority over the event loop ordering. flush pulls any pending
events off of the queue. You can specify to flush only recv events, only send events, or
any events, and you can specify a limit for how many events to flush in order to prevent
starvation.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="logging.html" title="Asynchronous Logging via PyZMQ"
             >next</a> |</li>
        <li class="right" >
          <a href="devices.html" title="Devices in PyZMQ"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
       <li><a href="api/index.html">API</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2011, Brian E. Granger &amp; Min Ragan-Kelley.  
ØMQ logo © iMatix Corportation, used under the Creative Commons Attribution-Share Alike 3.0 License.  
Python logo ™ of the Python Software Foundation, used by Min RK with permission from the Foundation.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.
    </div>
  </body>
</html>